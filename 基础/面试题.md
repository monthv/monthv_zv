#### 类和对象

类和对象是面向对象编程技术中的最基本的概念

范畴：

- 类是一个抽象的概念，它不存在于现实中的时间、空间里，类知识为所有的对象定义了抽象的属性与行为。 

- 对象是类的一个具体。它是一个实实在在存在的东西。 

#### 维护数据库的完整性、一致性、你喜欢用触发器还是自写业务逻辑？为什么?

尽可能用约束（包括CHECK、主键、唯一键、外键、非空字段）实现，这种方式的效率最好；其次用触发器，这种方式可以保证无论何种业务系统访问数据库都能维持数据库的完整性、一致性；最后再考虑用自写业务逻辑实现，但这种方式效率最低、编程最复杂，当为下下之策。

#### 什么是事务？什么是锁？

- 事务是指一个工作单元，它包含了一组数据操作命令，并且所有的命令作为一个整体一起向系统提交或撤消请求操作，即这组命令要么都执行，要么都不执行。
- 锁是在多用户环境中对数据的访问的限制。SqlServer自动锁定特定记录、字段或文件，防止用户访问，以维护数据安全或防止并发数据操作问题，锁可以保证事务的完整性和并发性。

#### 什么是索引，有什么优点？

索引象书的目录类似，索引使数据库程序无需扫描整个表，就可以在其中找到所需要的数据，索引包含了一个表中包含值的列表，其中包含了各个值的行所存储的位置，索引可以是单个或一组列，索引提供的表中数据的逻辑位置，合理划分索引能够大大提高数据库性能。

#### 什么是存储过程？有什么优点？

- 存储过程是一组予编译的SQL语句

  优点：

- 1.允许模块化程序设计，就是说只需要创建一次过程，以后在程序中就可以调用该过程任意次。

- 2.允许更快执行，如果某操作需要执行大量SQL语句或重复执行，存储过程比SQL语句执行的要快。

- 3.减少网络流量，例如一个需要数百行的SQL代码的操作有一条执行语句完成，不需要在网络中发送数百行代码。

- 4.更好的安全机制，对于没有权限执行存储过程的用户，也可授权他们执行存储过程。

#### C#中的委托是什么？事件是不是一种委托？

- 委托本质上是一种“方法接口”，它相当于C/C++中的函数指针，当然它比函数指针安全，在C#中通常用于事件处理。
- 事件不是委托，不过由于事件的性质决定了处理它的程序逻辑能访问的参数，因此，在C#中处理事件的逻辑都包装为委托。

#### 如何把一个array复制到arrayist里

foreach( object arr in array)arrayist.Add(arr);

####  列举ADO.NET中的五个主要对象，并简单描述

Connection连接对象，Command执行命令和存储过程，DataReader向前只读的数据流，DataAdapter适配器，支持增删查询，DataSet数据级对象，相当与内存里的一张或多张表。

#### 概述三层结构体系

表示层(UI),业务逻辑层(BLL),数据访问层(DAL)

#### 什么是装箱和拆箱？什么是重载？

- 装箱就是把值类型转成引用类型，拆箱相反把引用转换成值类型。
- 重载就是指一个方法名相同,参数个数不相同,返回值可以相同的方法。

#### 面向对象的思想主要包括什么？

继承、封装、多态

#### 列举一下你所了解的XML技术及其应用

xml可以用来做网页(xslt)、可以当作数据库、可以用来保存对象的系列化(web服务好象是基于这个的)。xml用于配置,用于保存静态数据类型.接触XML最多的是Web Services和config

#### C#中的[接口]()和[类]()有什么异同。

接口,是可以多继承,类只有单继承.接口强调了你必须实现,而没有具本实现的方法和虚类有点相似。

#### new 关键字用法

- new 运算符 用于创建对象和调用构造函数。
- new 修饰符 用于向基类成员隐藏继承成员。
- new 约束  用于在泛型声明中约束可能用作类型参数的参数的类型。

#### DataGrid的Datasouse可以连接什么数据源

DataTabe，DataView，DataSet，DataViewManager，任何实现IListSource接口的组件，任何实现IList接口的组件

#### 概述反射和序列化

- [反射]()：公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。
- [序列化]()：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。

#### 概述O/R Mapping 的原理

利用反射，配置将对象和数据库表映射。

#### 可访问性级别有哪几种

- pubic 访问不受限制。
- protected 访问仅限于包含类或从包含类派生的类型。
- internal 访问仅限于当前程序集。
- protected internal 访问仅限于从包含类派生的当前程序集或类型。
- private 访问仅限于包含类型。

#### C#中，string str = null 与 string str =""，请尽量用文字说明区别

string str=""初始化对象分配空间，而stringstr=null初始化对象

#### 什么叫应用程序域？什么是托管代码？什么是强类型系统？什么是装箱和拆箱？什么是重载？ CTS、CLS和CLR分别作何解释？

- 应用程序域：应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库宿主创建，运行库宿主负责在运行应用程序之前引导公共语言运行库。应用程序域提供了一个更安全、用途更广的处理单元，公共语言运行库可使用该单元提供应用程序之间的隔离。
- 托管代码：使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。
- 强类型：C# 是强类型语言；因此每个变量和对象都必须具有声明类型。
- 装箱和拆箱：装箱和拆箱使值类型能够被视为对象。对值类型装箱将把该值类型打包到 Object 引用类型的一个实例中。这使得值类型可以存储于垃圾回收堆中。拆箱将从对象中提取值类型。
- 重载：每个类型成员都有一个唯一的签名。方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。只要签名不同，就可以在一种类型内定义具有相同名称的多种方法。当定义两种或多种具有相同名称的方法时，就称作重载。
- CTS通用类型系统 (common type system) ：一种确定公共语言运行库如何定义、使用和管理类型的规范。
- CLR公共语言运行库：.NET Framework 提供了一个称为公共语言运行库的运行时环境，它运行代码并提供使开发过程更轻松的服务。
- CLS公共语言规范：要和其他对象完全交互，而不管这些对象是以何种语言实现的，对象必须只向调用方公开那些它们必须与之互用的所有语言的通用功能。为此定义了公共语言规范 (CLS)，它是许多应用程序所需的一套基本语言功能。

#### 值类型和引用类型的区别？

- 基于值类型的变量直接包含值。将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对对象的引用，而不复制对象本身。
- 所有的值类型均隐式派生自 System.ValueType。与引用类型不同，从值类型不可能派生出新的类型。但与引用类型相同的是，结构也可以实现接口。
- 与引用类型不同，值类型不可能包含 null 值。然而，可空类型功能允许将null 赋给值类型。 每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。
- 值类型主要由两类组成：结构、枚举； 结构分为以下几类：Numeric（数值）类型、整型、浮点型、decimal、bool、用户定义的结构。
- 引用类型的变量又称为对象，可存储对实际数据的引用。声明引用类型的关键字：class、interface、delegate、内置引用类型： object、string

#### 如何理解委托

委托类似于 C++ 函数指针，但它是类型安全的。委托允许将方法作为参数进行传递。委托可用于定义回调方法。委托可以链接在一起；例如，可以对一个事件调用多个方法。方法不需要与委托签名精确匹配。有关更多信息，请参见协变和逆变。C# 2.0 版引入了匿名方法的概念，此类方法允许将代码块作为参数传递，以代替单独定义的方法。

#### C#中的接口和类有什么异同？

[异]()：接口不能直接实例化。

　　接口不包含方法的实现。

　　接口、类和结构可从多个接口继承。但是C#类只支持单继承：类     只    能从一个基类继承实现。类定义可在不同的源文件之间进行拆分。

[同]()：接口、类和结构可从多个接口继承。

　　接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。

　　接口可以包含事件、索引器、方法和属性。

#### 如何理解.net中的垃圾回收机制

.NETFramework 的垃圾回收器管理应用程序的内存分配和释放。每次您使用 new 运算符创建对象时，运行库都从托管堆为该对象分配内存。只要托管堆中有地址空间可用，运行库就会继续为新对象分配空间。但是，内存不是无限大的。最终，垃圾回收器必须执行回收以释放一些内存。垃圾回收器优化引擎根据正在进行的分配情况确定执行回收的最佳时间。当垃圾回收器执行回收时，它检查托管堆中不再被应用程序使用的对象并执行必要的操作来回收它们占用的内存。

#### 概述.NET中的GC机制。

- GC的全称是garbage collection，中文名称垃圾回收，是.NET中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。
- 在进行垃圾回收时，垃圾回收器会首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起

#### GC是什么? 为什么要有GC?

GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： 
System.gc()
Runtime.getRuntime().gc()

#### ASP.NET中常见内置对象？

Response、Request、Server、Session、Application、Cookie

#### 接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？

接口是可以继承接口的，抽象类是可以实现接口的，抽象类可以继承实体类，但是有个条件，条件是，实体类必须要有明确的构造函数。

#### 用最有效的方法算出2乘以8等于几？

2<<3.